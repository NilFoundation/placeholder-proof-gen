# =nil; Proof Market (PoC)

# Introduction

This repository serves as a PoC of how a nil foundation supported proof market would operate.

The marketplace consists of the following entities.
- Proof Requester : This can be an application like a bridge requesting 
balance or a user interested in cross cluster operation and/or trust-less data access.
- Proof Generator : This is an entity who will generate the proofs for the requests/orders
made by the Proof Requester.

Below we will list a set of operations a user can follow along which demonstrates the market 
operation interaction between the above two entities.


# Dependencies

- [Boost](https://www.boost.org/) >= 1.74.0
- [cmake](https://cmake.org/) >= 3.5
- [clang](https://clang.llvm.org/) >= 14.0.6

On *nix systems, the following dependencies need to be present & can be installed using the following command

```
 sudo apt install build-essential libssl-dev libboost-all-dev cmake clang git
```


## Installation

Clone the repository
```
git clone git@github.com:NilFoundation/placeholder-proof-gen.git
cd placeholder-proof-gen.
```

- Clone all submodules recursively
```
git submodule update --init --recursive
```

# Proof Market Interaction

## 1. Circuit Generation/Publishing

Circuits can be generated by any one. They are serialised &  published on the proof market. 
This allows for reuse of the circuits by all other proof requesters. (TODO Check). Circuits need a set 
of public inputs. Below we create a new circuit and public params for it.

1.1  Create a new Circuit
```
cmake -build PATH_BUILD --target crypto3_placeholder_proof_gen_circuit_serialization_unified_addition_example -- -j 16
```

Execute the following to get a serialised json of circuit

```
PATH_BUILD/libs/placeholder-proof-gen/example/crypto3_placeholder_proof_gen_circuit_serialization_unified_addition_example
```

This circuit can now be pushed to the Proof market via curl command

**Request**

```
CURL --basic --user “root:” -X POST http://try.dbms.nil.foundation/circuit
{
  json output from above
}
```

**Response** (TODO : Check how additional params are in resp)
```
{
   "id": unique_id_of_circuit, 
   "name": "solana_state_proof"
   "repository": "https://github.com/NilFoundation/solana-state-proof"
   "info": "State Proof"
   "describe": "Circuit generates state proof for solana"
   "lambda": Lambda,
   "public_assignment": public_assignment,
   "desc": desc,
   "bp": bp
}
```


1.2 Add public params to circuit


Build
```
cmake  --build PATH_BUILD --target crypto3_placeholder_proof_gen_public_params_serialization_unified_addition_example  -- -j 16
```
Execute
```
/Users/zerg/Projects/solana/cmake-build-relwithdebinfo/libs/placeholder-proof-gen/example/crypto3_placeholder_proof_gen_public_params_serialization_unified_addition_example
```

## 2. Proof Market Order Creation

Once we have the artifacts/response from (1.1) && (1.2). The proof requester can create an order. Order
has additional details such as who is requesting the proof , what are they willing to pay for it and
how long is this order open to accept proposals from proof generators.

**Request**
```
CURL --basic --user “root:” -X POST http://try.dbms.nil.foundation/order
{
  "circuit_id": unique_id_of_circuit, // see 1.1 Response 
  "public_input": public_input  // see 1.2  TODO : how is this added here?
  "sender": pubkey, // Address of proof requestor (Hex) 
  "wait_period": time // how long will order stay open to accept proposals TODO : Should add fees?
}
```

**Response**
```
{
  "order_id": unique_order_id,
  "status": "registered",
  "circuit_id": unique_id_of_circuit,
  "public_input": public_input
  "sender": pubkey,
  "wait_period": time
  "proposal": Null,
  "proof": Null, 
}
```
This proof request is now visible to all proof generators.



## 3. Wait for proposals
Here the proof requester waits for proposals to be submitted against this order until
`wait_period` elapses or the requester finds a proposal they are happy with.



## 4. Submit Proposals
While the proposal is up, we now view at the marketplace from the perspective of a 
proof generator. In steps 1-3 , the requester put out an order. Now the generator can
observe them in the marketplace and start replying with proposals.

**Request**
```
CURL --basic --user “root:” -X POST http://try.dbms.nil.foundation/proposal
{
  "sender": pubkey, // Request generators payout address
  "bid": 225, // cost
  "order": unique_order_id, // id of order see 2.
  "eval_time": 1111, // proof geneation time in secs
}
```

**Response**
```
{
  "proposal_id : unique_proposal_id, TODO : Check , added by HG
  "sender": pubkey, 
  "bid": 225, 
  "order": unique_order_id,
  "eval_time": 1111,
}
```


## 5. Proposal Selection
We move back to the proof requesters' perspective. An order can have more than one proposals.
These could differ in `bid` price or `eval_time`. The requester then proceeds to select one 
that meets their need.

**Request**
```
CURL --basic --user “root:” -X POST http://try.dbms.nil.foundation/proposal_select
{
	"order_id": unique_order_id,
	"proposal": unique_proposal_id
}

```

**Response**

```
{
  "order_id": unique_order_id,
  "status": "in_process",
  "circuit_id": unique_id_of_circuit,
  "public_input": public_input
  "sender": pubkey,
  "wait_period": time
  "proposal": proposal_id,
  "proof": Null, 
}
```
The order thus shifts from `registered` to `in_process` and we tag on a new `proposal_id` to data.

# 6. Proof Generation
Moving back to perspective of Proof generator. The winning bid should now see the database 
and learn that their bid has won the proof market auction, and they should proceed to build
a proof for the requested circuit , consuming the specified inputs.

Execute the below to generate a proof (TODO : Update file names)
```
PATH_BULD/libs/placeholder-proof-gen/example/crypto3_placeholder_proof_gen_proof_generate_example —circuit=”circuit.json” —public_input=”public_input.json” —proof=“proof.out”
```

The proof is output in `proof.out`

# 7. Proof Submission
The proof generator can now submit the proof to the marketplace , where if verified, they will
get the reward. Invalid proof will incur a penalty.

**Request**

```
CURL --basic --user “root:” -X POST http://try.dbms.nil.foundation/proof
{
  "order_id": unique_order_id,
  "proof": proof,
}
```


**Response**
```
{
  "order_id": unique_order_id,
  "status": "completed",
  "circuit_id": unique_id_of_circuit,
  "public_input": public_input
  "sender": pubkey,
  "wait_period": time
  "proposal": proposal_id,
  "proof": proof, 
}
```
We notice `proof` and `status` attributes are now updated.


# Common issues

## Compilation Errors
If you have more than one compiler installed i.e g++ & clang++. The make system might pick up the former. You can explicitly force usage of
clang++ by finding the path and passing it in the variable below.

```
`which clang++`  
cmake .. -DCMAKE_CXX_COMPILER=<path to clang++ from above>
```

## Submodule management
Git maintains a few places where submodule details are cached. Sometimes updates do not come through. ex: Deletion , updating
a url of a previously checked out submodule.It is advisable to check these locations for remains or try a new checkout.
- .gitmodules
- .git/config
- .git/modules/*